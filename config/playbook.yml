---
# =============================================================
#  Play 1 : Configuration de base - Tous les noeuds
# =============================================================
- name: Configuration de base - Tous les noeuds
  hosts: all
  become: yes
  gather_facts: false
  pre_tasks:
    - name: Attente de la connectivité SSH
      wait_for_connection:
        delay: 10
        timeout: 180

    - name: Collecte des facts
      setup:
  tasks:
    - name: Mise à jour du cache APT
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Installation des dépendances système
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg-agent
          - software-properties-common
          - nfs-common
          - openssl
        state: present

    - name: Ajout de la clé GPG Docker
      shell: |
        install -m 0755 -d /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
        chmod a+r /etc/apt/keyrings/docker.asc
      args:
        creates: /etc/apt/keyrings/docker.asc

    - name: Ajout du dépôt Docker APT
      shell: |
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list
        apt-get update -qq
      args:
        creates: /etc/apt/sources.list.d/docker.list

    - name: Installation de Docker CE
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-compose-plugin
        state: present
        update_cache: yes

    - name: Activation et démarrage de Docker
      systemd:
        name: docker
        enabled: yes
        state: started

    - name: Ajout de vagrant au groupe docker
      user:
        name: vagrant
        groups: docker
        append: yes

    - name: Recharger la connexion SSH (pour prise en compte du groupe docker)
      meta: reset_connection

    - name: Création du répertoire partagé
      file:
        path: /mnt/shared
        state: directory
        mode: '0755'
        owner: vagrant
        group: vagrant

    # --- Pare-feu UFW ---
    - name: Installation UFW
      apt:
        name: ufw
        state: present

    - name: UFW - Autoriser SSH
      ufw:
        rule: allow
        port: '22'
        proto: tcp

    - name: UFW - Autoriser HTTP
      ufw:
        rule: allow
        port: '80'
        proto: tcp

    - name: UFW - Autoriser HTTPS
      ufw:
        rule: allow
        port: '443'
        proto: tcp

    - name: UFW - Docker Swarm Management
      ufw:
        rule: allow
        port: '2377'
        proto: tcp

    - name: UFW - Docker Overlay Network (UDP)
      ufw:
        rule: allow
        port: '4789'
        proto: udp

    - name: UFW - Docker Node Communication (TCP)
      ufw:
        rule: allow
        port: '7946'
        proto: tcp

    - name: UFW - Docker Node Communication (UDP)
      ufw:
        rule: allow
        port: '7946'
        proto: udp

    - name: UFW - Autoriser NFS (réseau local uniquement)
      ufw:
        rule: allow
        port: '2049'
        proto: tcp
        src: '192.168.56.0/24'

    - name: UFW - Activer avec politique deny par défaut
      ufw:
        state: enabled
        policy: deny

    # --- Optimisation noyau ---
    - name: Optimisation - Réduire le swappiness
      sysctl:
        name: vm.swappiness
        value: '10'
        sysctl_set: yes

    - name: Optimisation - Augmenter le max open files
      sysctl:
        name: fs.file-max
        value: '65535'
        sysctl_set: yes

    # --- Hardening SSH ---
    - name: SSH - Désactiver le login root
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PermitRootLogin'
        line: 'PermitRootLogin no'
      notify: Restart SSH

    - name: SSH - Désactiver l'authentification par mot de passe
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PasswordAuthentication'
        line: 'PasswordAuthentication no'
      notify: Restart SSH

  handlers:
    - name: Restart SSH
      service:
        name: ssh
        state: restarted

# =============================================================
#  Play 2 : Serveur NFS sur le Manager
# =============================================================
- name: Configuration NFS - Serveur (Manager)
  hosts: managers
  become: yes
  tasks:
    - name: Installation du serveur NFS
      apt:
        name: nfs-kernel-server
        state: present

    - name: Configuration des exports NFS (réseau local)
      lineinfile:
        path: /etc/exports
        line: '/mnt/shared 192.168.56.0/24(rw,sync,no_subtree_check,no_root_squash)'
        create: yes
      notify: Restart NFS

    - name: Export des partages NFS
      command: exportfs -ra
      changed_when: false

  handlers:
    - name: Restart NFS
      service:
        name: nfs-kernel-server
        state: restarted

# =============================================================
#  Play 3 : Montage NFS sur les Workers UNIQUEMENT
# =============================================================
- name: Montage NFS - Workers uniquement
  hosts: workers
  become: yes
  tasks:
    - name: Montage du volume partagé NFS
      mount:
        path: /mnt/shared
        src: "{{ hostvars[groups['managers'][0]]['ansible_host'] }}:/mnt/shared"
        fstype: nfs
        opts: defaults,_netdev,nofail
        state: mounted

# =============================================================
#  Play 4 : Initialisation du cluster Docker Swarm
# =============================================================
- name: Initialisation du cluster Swarm
  hosts: managers
  become: yes
  tasks:
    - name: Vérifier si Swarm est déjà initialisé
      shell: docker info 2>/dev/null | grep -oP 'Swarm:\s+\K\w+'
      register: swarm_status
      changed_when: false
      failed_when: false

    - name: Initialiser Docker Swarm
      command: docker swarm init --advertise-addr {{ ansible_host }}
      when: swarm_status.stdout != 'active'

    - name: Récupérer le token Worker
      command: docker swarm join-token -q worker
      register: worker_token
      changed_when: false

# =============================================================
#  Play 5 : Joindre les Workers au Swarm
# =============================================================
- name: Joindre les Workers au Swarm
  hosts: workers
  become: yes
  tasks:
    - name: Vérifier si le noeud est déjà dans le Swarm
      shell: docker info 2>/dev/null | grep -oP 'Swarm:\s+\K\w+'
      register: swarm_status
      changed_when: false
      failed_when: false

    - name: Rejoindre le Swarm
      command: >
        docker swarm join
        --token {{ hostvars[groups['managers'][0]]['worker_token']['stdout'] }}
        {{ hostvars[groups['managers'][0]]['ansible_host'] }}:2377
      when: swarm_status.stdout != 'active'

# =============================================================
#  Play 6 : Déploiement des fichiers applicatifs + Stack
# =============================================================
- name: Déploiement applicatif sur le Manager
  hosts: managers
  become: no
  tasks:
    - name: Copie des fichiers applicatifs
      copy:
        src: "{{ playbook_dir }}/../app/"
        dest: /home/vagrant/
        owner: vagrant
        group: vagrant

    - name: Rendre les scripts exécutables
      file:
        path: "/home/vagrant/scripts/{{ item }}"
        mode: '0755'
      loop:
        - init-stack.sh
        - init-letsencrypt.sh

    - name: Vérifier si la stack est déjà déployée
      shell: docker stack ls --format {% raw %}'{{.Name}}'{% endraw %} | grep -q glpi_stack
      register: stack_exists
      changed_when: false
      failed_when: false

    - name: Initialiser la stack Docker Swarm
      shell: /home/vagrant/scripts/init-stack.sh
      args:
        chdir: /home/vagrant
      when: stack_exists.rc != 0

# =============================================================
#  Play 7 : Attente de GLPI et lecture des credentials
# =============================================================
- name: Attente de la disponibilité de GLPI
  hosts: managers
  become: no
  tasks:
    - name: Attente de GLPI (HTTP 200)
      shell: curl -s -o /dev/null -w '%{http_code}' http://localhost/
      register: http_check
      until: http_check.stdout == "200"
      retries: 30
      delay: 10
      changed_when: false

    - name: Lire le mot de passe de la BDD
      shell: grep "Password" /home/vagrant/.glpi_credentials | head -1 | awk '{print $NF}'
      register: db_password_result
      changed_when: false

    - name: Stocker le mot de passe comme fait partagé
      set_fact:
        glpi_db_password: "{{ db_password_result.stdout }}"

# =============================================================
#  Play 8 : Installation automatique de la BDD GLPI
# =============================================================
- name: Installation de la base de données GLPI
  hosts: swarm
  become: no
  tasks:
    - name: Chercher le conteneur GLPI sur ce noeud
      shell: docker ps -q -f name=glpi_stack_glpi
      register: glpi_container
      changed_when: false
      failed_when: false

    - name: Installer la base de données GLPI
      shell: |
        docker exec {{ glpi_container.stdout }} php /var/www/html/glpi/bin/console database:install \
          --db-host=mariadb --db-port=3306 --db-name=glpi --db-user=glpi \
          --db-password={{ hostvars[groups['managers'][0]]['glpi_db_password'] }} \
          --default-language=fr_FR --no-interaction --force --allow-superuser
      when: glpi_container.stdout != ""
      register: glpi_install_result
      failed_when: false

# =============================================================
#  Play 9 : Configuration SSL et finalisation
# =============================================================
- name: Configuration SSL et finalisation
  hosts: managers
  become: no
  tasks:
    - name: Exécuter le script de configuration SSL
      shell: /home/vagrant/scripts/init-letsencrypt.sh
      args:
        chdir: /home/vagrant
      register: ssl_result
      failed_when: false

    - name: Lire le fichier de credentials
      slurp:
        src: /home/vagrant/.glpi_credentials
      register: credentials_file

    - name: Sauvegarder les credentials localement
      local_action:
        module: copy
        content: "{{ credentials_file.content | b64decode }}"
        dest: "{{ playbook_dir }}/../.glpi_credentials"
        mode: '0600'
